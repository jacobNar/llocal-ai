import { app, BrowserWindow, ipcMain } from 'electron';
import { InferenceClient } from "@huggingface/inference";
import { tool } from '@langchain/core/tools';
import { z } from 'zod';
import { ToolNode } from '@langchain/langgraph/prebuilt';
import type { Document } from '@langchain/core/documents';
import { MemorySaver, StateGraph, Annotation, START, END } from "@langchain/langgraph";
import { BaseMessage, ToolMessage, HumanMessage, AIMessage, SystemMessage } from "@langchain/core/messages";
import puppeteer, { Browser } from 'puppeteer';
import { RunnableConfig } from "@langchain/core/runnables";
import { zodToJsonSchema } from "zod-to-json-schema";
import * as dotenv from 'dotenv';
import {
  getInteractibleElementsTool,
  loadWebpageTool,
  clickElementTool,
  setBrowserInstance,
  typeTextTool,
  scrollPageTool // Added scrollPageTool
} from './tools/browser-tools';
import { responseTool } from './tools/response-tool';
import webCrawlerTool from './tools/web-crawler-tools';
import { MemoryVectorStore } from 'langchain/vectorstores/memory';
import { RecursiveCharacterTextSplitter } from 'langchain/text_splitter';
import { OllamaEmbeddings } from '@langchain/ollama';
import { DatabaseService } from './services/db'; // Import DB Service

dotenv.config();

const executablePath = "C:/Program Files/Google/Chrome/Application/chrome.exe";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}
//APP GLOBALS
let browser: Browser;
let mainWindow: BrowserWindow;
let vectorStore: MemoryVectorStore;
let agent: any;
let db: DatabaseService; // DB Instance
const textSplitter = new RecursiveCharacterTextSplitter({ chunkSize: 200, chunkOverlap: 0 });

const createWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    height: 1080,
    width: 1920,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  // mainWindow.webContents.openDevTools();
};

app.on('ready', () => {
  db = new DatabaseService(); // Initialize DB
  initAgent();
  initBrowser();
  createWindow();
});

// Quit when all windows are closed, except on macOS. There, it's common for applications and their menu bar to stay active until the user quits explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  initAgent();
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});


// Initialize LLM, embeddings, tools, and agent
const initAgent = () => {

  // Initialize Vector Store for other tools (if needed)
  const embeddings = new OllamaEmbeddings({
    baseUrl: 'http://localhost:11434/',
    model: 'llama3.2',
  });

  const client = new InferenceClient(process.env.HF_TOKEN);

  vectorStore = new MemoryVectorStore(embeddings);

  // Define Tools
  const tools = [loadWebpageTool, getInteractibleElementsTool, clickElementTool, typeTextTool, scrollPageTool, responseTool];
  const toolsMap = Object.fromEntries(tools.map(t => [t.name, t]));

  // Define State
  const AgentState = Annotation.Root({
    messages: Annotation<BaseMessage[]>({
      reducer: (x, y) => x.concat(y),
    }),
  });

  // System Prompt Construction
  const getSystemPrompt = () => {
    return `**PRIMARY DIRECTIVE:** You are a dedicated, persistent web browsing expert. Your SOLE function is to achieve the user's task using the provided tools. 
    **You must NEVER state that you cannot proceed or lack information.** If you need information, you MUST call the appropriate tool to get it. 
    **NEVER** ask for permission, clarification, or further instructions once the task is started. Do not state you are analyzing or planning. never ask me to review something either.

    **TASK FLOW:**
    1. Always start with 'Load Webpage' to visit the URL if provided.
    2. Call 'Get Interactible Elements From Current Webpage' to see what elements are available to interact with.
    3. Use 'Click Element' to navigate or interact.
    4. Only when the final requested information is in your possession, use the 'Response' tool to provide the answer.`;
  };

  const callModel = async (state: typeof AgentState.State, config: RunnableConfig) => {
    const messages = state.messages;
    const hfMessages: any[] = [
      { role: "system", content: getSystemPrompt() }
    ];

    // Find the last index of the interactible elements tool message
    let lastInteractibleToolIndex = -1;
    for (let i = messages.length - 1; i >= 0; i--) {
      const m = messages[i];
      if (m instanceof ToolMessage && m.name === 'Get Interactible Elements From Current Webpage') {
        lastInteractibleToolIndex = i;
        break;
      }
    }

    messages.forEach((m, index) => {
      if (m instanceof HumanMessage) {
        hfMessages.push({ role: "user", content: m.content.toString() });
      } else if (m instanceof AIMessage) {
        hfMessages.push({ role: "assistant", content: m.content.toString() });
      } else if (m instanceof ToolMessage) {
        // Only include the most recent Interactible Elements tool output
        if (m.name === 'Get Interactible Elements From Current Webpage') {
          if (index === lastInteractibleToolIndex) {
            hfMessages.push({ role: "user", content: `Tool Output: ${m.content.toString()}` });
          }
        } else {
          hfMessages.push({ role: "user", content: `Tool Output: ${m.content.toString()}` });
        }
      }
    });

    console.log(`Calling model with ${hfMessages.length} messages`);

    if (!process.env.HF_TOKEN) {
      console.warn("Missing HF_TOKEN environment variable");
    }

    console.log("Payload Preview:", JSON.stringify(hfMessages[hfMessages.length - 1])); //

    const model = "meta-llama/Llama-3.1-70B-Instruct";

    let content = "";
    const toolCalls: any[] = [];

    const formattedTools = tools.map((t) => {
      const jsonSchema = zodToJsonSchema(t.schema as z.ZodType<any>);
      delete (jsonSchema as any).$schema;
      return {
        type: "function",
        function: {
          name: t.name,
          description: t.description,
          parameters: jsonSchema,
        },
      };
    });

    // console.log("Formatted Tools:", JSON.stringify(formattedTools, null, 2));

    try {
      const chatCompletion = await client.chatCompletion({
        model: model,
        messages: hfMessages,
        max_tokens: 2048,
        temperature: 0.8,
        tools: formattedTools,
        tool_choice: "auto",
      });

      const message = chatCompletion.choices[0].message;
      console.log(JSON.stringify(message))
      content = message.content || "";

      // Check for native tool calls first
      if (message.tool_calls && message.tool_calls.length > 0) {
        message.tool_calls.forEach((tc: any) => {
          toolCalls.push({
            name: tc.function.name,
            args: typeof tc.function.arguments === 'string' ? JSON.parse(tc.function.arguments) : tc.function.arguments,
            id: tc.id || `call_${Date.now()}`
          });
        });
      }

    } catch (e) {
      console.error("HF Inference Error:", e);
      content = "Error calling model: " + (e instanceof Error ? e.message : String(e));
    }

    console.log("Model response:", content);

    console.log("tool calls:", toolCalls);

    const aiMessage = new AIMessage({
      content: content,
      tool_calls: toolCalls
    });

    return { messages: [aiMessage] };
  };

  const callTool = async (state: typeof AgentState.State) => {
    const lastMessage = state.messages[state.messages.length - 1] as AIMessage;
    if (!lastMessage.tool_calls || lastMessage.tool_calls.length === 0) {
      return { messages: [] };
    }

    const toolCall = lastMessage.tool_calls[0];
    const tool = toolsMap[toolCall.name];

    if (!tool) {
      return {
        messages: [new ToolMessage({
          tool_call_id: toolCall.id || "unknown",
          content: `Error: Tool ${toolCall.name} not found. Available tools: ${Object.keys(toolsMap).join(", ")}`,
          name: toolCall.name
        })]
      }
    }

    console.log(`Executing tool ${toolCall.name} with args`, toolCall.args);
    try {
      const result = await tool.invoke(toolCall.args);
      // The tool returns a ToolMessage, may need to ensure id matches
      if (result instanceof ToolMessage) {
        result.tool_call_id = toolCall.id || "unknown";
        return { messages: [result] };
      }

      return {
        messages: [new ToolMessage({
          tool_call_id: toolCall.id || "unknown",
          content: typeof result === 'string' ? result : JSON.stringify(result),
          name: toolCall.name
        })]
      };

    } catch (error) {
      return {
        messages: [new ToolMessage({
          tool_call_id: toolCall.id || "unknown",
          content: `Tool execution error: ${error instanceof Error ? error.message : String(error)}`,
          name: toolCall.name
        })]
      }
    }
  };

  const shouldContinue = (state: typeof AgentState.State) => {
    const lastMessage = state.messages[state.messages.length - 1] as AIMessage;
    if (lastMessage.tool_calls && lastMessage.tool_calls.length > 0) {
      if (lastMessage.tool_calls[0].name === "Response") {
        return END;
      }
      return "tool";
    }
    return END;
  };

  const workflow = new StateGraph(AgentState)
    .addNode("agent", callModel)
    .addNode("tool", callTool)
    .addEdge(START, "agent")
    .addConditionalEdges("agent", shouldContinue, {
      tool: "tool",
      [END]: END
    })
    .addEdge("tool", "agent");

  // Initialize memory wrapper
  const memory = new MemorySaver();
  agent = workflow.compile({ checkpointer: memory });
  console.log("Agent initialized");
};

const initBrowser = async () => {
  browser = await puppeteer.launch({
    headless: false,
    executablePath: executablePath,
    defaultViewport: null,
    args: ['--start-maximized', "--no-sandbox", "--disable-setuid-sandbox"]
  });
  setBrowserInstance(browser);
  console.log("chromium started");
}

// IPC to handle user queries
// IPC to handle user queries
ipcMain.handle('runQuery', async (event, { message, conversationId }: { message: string, conversationId?: string }) => {
  try {
    console.log("runQuery called with message: ", message, " conversationId: ", conversationId);

    // If no conversationId, create new
    if (!conversationId) {
      conversationId = db.createConversation(message.substring(0, 30) + "...");
    }

    // Save user message
    db.addMessage(conversationId, 'user', message);

    const config = { configurable: { thread_id: conversationId } }; // Use conversationId as thread_id for memory

    // Convert string input to HumanMessage
    const result = await agent.invoke({
      messages: [new HumanMessage(message)]
    }, config);

    // Extract final response
    const messages = result.messages;
    const lastMsg = messages[messages.length - 1];

    let finalResponse = lastMsg.content;
    if (lastMsg.tool_calls && lastMsg.tool_calls.length > 0) {
      const lastTool = lastMsg.tool_calls[0];
      if (lastTool.name === "Response") {
        finalResponse = lastTool.args.response;
      }
    }

    // Save agent response
    db.addMessage(conversationId, 'assistant', String(finalResponse));

    return {
      messages: messages.map((m: BaseMessage) => ({
        content: m.content,
        type: m._getType()
      })),
      final_response: finalResponse,
      conversationId: conversationId // Return ID so frontend can update
    };

  } catch (error) {
    console.error("Error in runQuery:", error);
    return error;
  }
});

ipcMain.handle('getHistory', async () => {
  return db.getConversations();
});

ipcMain.handle('loadConversation', async (event, conversationId: string) => {
  return db.getMessages(conversationId);
});

// Helper for specialized tools (e.g. web crawler)
ipcMain.handle("webCrawlerTool", async (event, url) => {
  try {
    const response = await webCrawlerTool(url);
    const urlPages = Object.values(response)
    const urls = Object.keys(response)

    urlPages.map(async (urlPage: string, index: number) => {
      const sentences = await textSplitter.splitText(urlPage);
      const documents = sentences.map(sentence => ({
        pageContent: sentence,
        metadata: { url: urls[index] }
      }));
      await vectorStore.addDocuments(documents)
    })
    return "Indexed " + url; // Return something
  } catch (e) {
    console.error(e);
    return "Error indexing: " + e;
  }
});
