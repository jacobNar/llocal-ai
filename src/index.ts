import { app, BrowserWindow, ipcMain } from 'electron';
import { InferenceClient } from "@huggingface/inference";
import { tool } from '@langchain/core/tools';
import { z } from 'zod';
import { ToolNode } from '@langchain/langgraph/prebuilt';
import type { Document } from '@langchain/core/documents';
import { MemorySaver, StateGraph, Annotation, START, END } from "@langchain/langgraph";
import { BaseMessage, ToolMessage, HumanMessage, AIMessage, SystemMessage } from "@langchain/core/messages";
import puppeteer, { Browser } from 'puppeteer';
import { RunnableConfig } from "@langchain/core/runnables";
import { zodToJsonSchema } from "zod-to-json-schema";
import * as dotenv from 'dotenv';
import {
  getInteractibleElementsTool,
  loadWebpageTool,
  clickElementTool,
  setBrowserInstance,
  typeTextTool,
  scrollPageTool // Added scrollPageTool
} from './tools/browser-tools';
import { responseTool } from './tools/response-tool';
import webCrawlerTool from './tools/web-crawler-tools';
import { MemoryVectorStore } from 'langchain/vectorstores/memory';
import { RecursiveCharacterTextSplitter } from 'langchain/text_splitter';
import { OllamaEmbeddings } from '@langchain/ollama';

dotenv.config();

const executablePath = "C:/Program Files/Google/Chrome/Application/chrome.exe";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}
//APP GLOBALS
let browser: Browser;
let mainWindow: BrowserWindow;
let vectorStore: MemoryVectorStore;
let agent: any;
const textSplitter = new RecursiveCharacterTextSplitter({ chunkSize: 200, chunkOverlap: 0 });

const createWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    height: 1080,
    width: 1920,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  // mainWindow.webContents.openDevTools();
};

app.on('ready', () => {
  initAgent();
  initBrowser();
  createWindow();
});

// Quit when all windows are closed, except on macOS. There, it's common for applications and their menu bar to stay active until the user quits explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  initAgent();
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});


// Initialize LLM, embeddings, tools, and agent
const initAgent = () => {

  // Initialize Vector Store for other tools (if needed)
  const embeddings = new OllamaEmbeddings({
    baseUrl: 'http://localhost:11434/',
    model: 'llama3.2',
  });
  vectorStore = new MemoryVectorStore(embeddings);

  // Define Tools
  const tools = [loadWebpageTool, getInteractibleElementsTool, clickElementTool, typeTextTool, scrollPageTool, responseTool];
  const toolsMap = Object.fromEntries(tools.map(t => [t.name, t]));

  // Define State
  const AgentState = Annotation.Root({
    messages: Annotation<BaseMessage[]>({
      reducer: (x, y) => x.concat(y),
    }),
  });

  // System Prompt Construction
  const getSystemPrompt = () => {
    let toolsStr = "";
    tools.forEach(tool => {
      const schema = zodToJsonSchema(tool.schema as z.ZodType<any>);
      toolsStr += `Tool: ${tool.name}\nDescription: ${tool.description}\nArguments: ${JSON.stringify(schema)}\n\n`;
    });

    return `**PRIMARY DIRECTIVE:** You are a dedicated, persistent web browsing expert. Your SOLE function is to achieve the user's task using the provided tools. 
**You must NEVER state that you cannot proceed or lack information.** If you need information, you MUST call the appropriate tool to get it. 
**NEVER** ask for permission, clarification, or further instructions once the task is started. Do not state you are analyzing or planning. never ask me to review something either.
**OUTPUT REQUIREMENTS:**
1. **Your output must ALWAYS be a valid JSON object representing a tool call.**
2. **Do NOT output any conversational text outside of the JSON.**
3. **If you have the final answer for the user, you MUST use the 'Response' tool.**

Here's an example of a good tool call output:
{"name": "Load Webpage", "arguments": {"url": "https://example.com"}}

**IMPORTANT:** Even if the tool takes no arguments, you MUST use the JSON format with an empty 'arguments' object.
**IMPORTANT:** The response for a tool call must contain the entire complete JSON of the tool call like above with the "name" and "arguments" keys.

**TASK FLOW:**
1. Always start with 'Load Webpage' to visit the URL if provided.
2. Call 'Get Interactible Elements From Current Webpage' to see what elements are available to interact with.
3. Use 'Click Element' to navigate or interact.
4. Only when the final requested information is in your possession, use the 'Response' tool to provide the answer.

**AVAILABLE TOOLS:**
${toolsStr}`;
  };

  const callModel = async (state: typeof AgentState.State, config: RunnableConfig) => {
    const messages = state.messages;
    const hfMessages: any[] = [
      { role: "system", content: getSystemPrompt() }
    ];

    // Find the last index of the interactible elements tool message
    let lastInteractibleToolIndex = -1;
    for (let i = messages.length - 1; i >= 0; i--) {
      const m = messages[i];
      if (m instanceof ToolMessage && m.name === 'Get Interactible Elements From Current Webpage') {
        lastInteractibleToolIndex = i;
        break;
      }
    }

    messages.forEach((m, index) => {
      if (m instanceof HumanMessage) {
        hfMessages.push({ role: "user", content: m.content.toString() });
      } else if (m instanceof AIMessage) {
        hfMessages.push({ role: "assistant", content: m.content.toString() });
      } else if (m instanceof ToolMessage) {
        // Only include the most recent Interactible Elements tool output
        if (m.name === 'Get Interactible Elements From Current Webpage') {
          if (index === lastInteractibleToolIndex) {
            hfMessages.push({ role: "user", content: `Tool Output: ${m.content.toString()}` });
          }
        } else {
          hfMessages.push({ role: "user", content: `Tool Output: ${m.content.toString()}` });
        }
      }
    });

    console.log(`Calling model with ${hfMessages.length} messages`);

    if (!process.env.HF_TOKEN) {
      console.warn("Missing HF_TOKEN environment variable");
    }

    console.log("Payload Preview:", JSON.stringify(hfMessages[hfMessages.length - 1])); //

    const client = new InferenceClient(process.env.HF_TOKEN);
    const model = "Qwen/Qwen2.5-Coder-32B-Instruct";

    let content = "";
    try {
      const chatCompletion = await client.chatCompletion({
        model: model,
        messages: hfMessages,
        max_tokens: 2048,
        temperature: 0.8,
      });
      content = chatCompletion.choices[0].message.content || "";
    } catch (e) {
      console.error("HF Inference Error:", e);
      content = "Error calling model: " + (e instanceof Error ? e.message : String(e));
    }

    console.log("Model response:", content);

    const toolCalls: any[] = [];

    try {
      const jsonParams = JSON.parse(content);
      if (jsonParams.name && jsonParams.arguments) {
        toolCalls.push({
          name: jsonParams.name,
          args: jsonParams.arguments,
          id: `call_${Date.now()}`
        });
      }
    } catch (e) {
      // If not valid JSON, try extracting it using Regex or look for substrings
      const jsonMatch = content.match(/\{[\s\S]*"name"[\s\S]*"arguments"[\s\S]*\}/);
      if (jsonMatch) {
        try {
          const jsonParams = JSON.parse(jsonMatch[0]);
          if (jsonParams.name && jsonParams.arguments) {
            toolCalls.push({
              name: jsonParams.name,
              args: jsonParams.arguments,
              id: `call_${Date.now()}`
            });
          }
        } catch (innerE) {
          console.log("Failed to parse extracted JSON");
        }
      }
    }

    console.log("Parsed tool calls:", toolCalls);

    const aiMessage = new AIMessage({
      content: content,
      tool_calls: toolCalls
    });

    return { messages: [aiMessage] };
  };

  const callTool = async (state: typeof AgentState.State) => {
    const lastMessage = state.messages[state.messages.length - 1] as AIMessage;
    if (!lastMessage.tool_calls || lastMessage.tool_calls.length === 0) {
      return { messages: [] };
    }

    const toolCall = lastMessage.tool_calls[0];
    const tool = toolsMap[toolCall.name];

    if (!tool) {
      return {
        messages: [new ToolMessage({
          tool_call_id: toolCall.id || "unknown",
          content: `Error: Tool ${toolCall.name} not found. Available tools: ${Object.keys(toolsMap).join(", ")}`,
          name: toolCall.name
        })]
      }
    }

    console.log(`Executing tool ${toolCall.name} with args`, toolCall.args);
    try {
      const result = await tool.invoke(toolCall.args);
      // The tool returns a ToolMessage, may need to ensure id matches
      if (result instanceof ToolMessage) {
        result.tool_call_id = toolCall.id || "unknown";
        return { messages: [result] };
      }

      return {
        messages: [new ToolMessage({
          tool_call_id: toolCall.id || "unknown",
          content: typeof result === 'string' ? result : JSON.stringify(result),
          name: toolCall.name
        })]
      };

    } catch (error) {
      return {
        messages: [new ToolMessage({
          tool_call_id: toolCall.id || "unknown",
          content: `Tool execution error: ${error instanceof Error ? error.message : String(error)}`,
          name: toolCall.name
        })]
      }
    }
  };

  const shouldContinue = (state: typeof AgentState.State) => {
    const lastMessage = state.messages[state.messages.length - 1] as AIMessage;
    if (lastMessage.tool_calls && lastMessage.tool_calls.length > 0) {
      if (lastMessage.tool_calls[0].name === "Response") {
        return END;
      }
      return "tool";
    }
    return END;
  };

  const workflow = new StateGraph(AgentState)
    .addNode("agent", callModel)
    .addNode("tool", callTool)
    .addEdge(START, "agent")
    .addConditionalEdges("agent", shouldContinue, {
      tool: "tool",
      [END]: END
    })
    .addEdge("tool", "agent");

  // Initialize memory wrapper
  const memory = new MemorySaver();
  agent = workflow.compile({ checkpointer: memory });
  console.log("Agent initialized");
};

const initBrowser = async () => {
  browser = await puppeteer.launch({ headless: false, executablePath: executablePath });
  setBrowserInstance(browser);
  console.log("chromium started");
}

// IPC to handle user queries
ipcMain.handle('runQuery', async (event, message: string) => {
  try {
    console.log("runQuery called with message: ", message)

    const config = { configurable: { thread_id: "1" } };

    // Convert string input to HumanMessage
    const result = await agent.invoke({
      messages: [new HumanMessage(message)]
    }, config);

    // Extract final response
    const messages = result.messages;
    const lastMsg = messages[messages.length - 1];

    let finalResponse = lastMsg.content;
    if (lastMsg.tool_calls && lastMsg.tool_calls.length > 0) {
      const lastTool = lastMsg.tool_calls[0];
      if (lastTool.name === "Response") {
        finalResponse = lastTool.args.response;
      }
    }

    return {
      messages: messages.map((m: BaseMessage) => ({
        content: m.content,
        type: m._getType()
      })),
      final_response: finalResponse
    };

  } catch (error) {
    console.error("Error in runQuery:", error);
    return error;
  }
});

// Helper for specialized tools (e.g. web crawler)
ipcMain.handle("webCrawlerTool", async (event, url) => {
  try {
    const response = await webCrawlerTool(url);
    const urlPages = Object.values(response)
    const urls = Object.keys(response)

    urlPages.map(async (urlPage: string, index: number) => {
      const sentences = await textSplitter.splitText(urlPage);
      const documents = sentences.map(sentence => ({
        pageContent: sentence,
        metadata: { url: urls[index] }
      }));
      await vectorStore.addDocuments(documents)
    })
    return "Indexed " + url; // Return something
  } catch (e) {
    console.error(e);
    return "Error indexing: " + e;
  }
});
