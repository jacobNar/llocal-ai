import { app, BrowserWindow, ipcMain  } from 'electron';
import { ChatOllama, OllamaEmbeddings } from '@langchain/ollama';
import { MemoryVectorStore } from 'langchain/vectorstores/memory';
import { RecursiveCharacterTextSplitter } from 'langchain/text_splitter';
import { tool } from '@langchain/core/tools';
import { z } from 'zod';
import { createReactAgent, ToolNode } from '@langchain/langgraph/prebuilt';
import type { Document } from '@langchain/core/documents';
import { MemorySaver,StateGraph, Annotation, START, END , MessagesAnnotation } from "@langchain/langgraph";
import { HumanMessage, AIMessage, BaseMessage, ToolMessage } from "@langchain/core/messages";
import puppeteer, { Browser } from 'puppeteer';

const executablePath = "C:/Program Files/Google/Chrome/Application/chrome.exe";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}
//APP GLOBALS
let browser: Browser;
let mainWindow: BrowserWindow;
let vectorStore: MemoryVectorStore;
let agent: any;
const textSplitter = new RecursiveCharacterTextSplitter({ chunkSize: 200, chunkOverlap: 0 });

const createWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  mainWindow.webContents.openDevTools();
};

app.on('ready', () => {
  initAgent();
  initBrowser();
  createWindow();
});

// Quit when all windows are closed, except on macOS. There, it's common for applications and their menu bar to stay active until the user quits explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  initAgent();
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});


// Initialize LLM, embeddings, tools, and agent
const initAgent = () => {

  const AgentState = Annotation.Root({
    messages: Annotation<BaseMessage[]>({
      reducer: (x, y) => x.concat(y),
    }),
  });
  
  const llm = new ChatOllama({
    baseUrl: 'http://localhost:11434/',
    model: 'llama3.2',
    temperature: 0,
    maxRetries: 2,
  });

  const embeddings = new OllamaEmbeddings({
    baseUrl: 'http://localhost:11434/',
    model: 'llama3.2',
  });

  vectorStore = new MemoryVectorStore(embeddings);
  const memory = new MemorySaver();

  const similaritySearchTool = tool(async ({ query }: { query: string }, { toolCallId }: { toolCallId: string }): Promise<ToolMessage> => {
    console.log("tool call id: " + toolCallId)
    console.log("Similarity search tool called with query: ", query);
    const results: Document[] = await vectorStore.similaritySearch(query, 30);
    const content =  results.map(r => r.pageContent).join('\n\n');
    
    return new ToolMessage({
      tool_call_id: toolCallId,
      content,
    });

  }, {
    name: 'Knowledge base similarity search',
    description: 'Search vector store with for relevant context to answer the user\'s query using similarity search.',
    schema: z.object({
      query: z.string().describe('Search query'),
    }),
  });

  const getInteractibleElementsTool = tool(async (_: any, { toolCallId }: { toolCallId: string }): Promise<ToolMessage> => {
    console.log("grabbing interactible elements from current page")
    const pages = await browser.pages();
    const currentPage = pages[pages.length - 1];

    const content = await currentPage.evaluate(() => {
      // Find interactive elements and elements with click handlers
      const baseSelectors = 'a, button, input, textarea, select';
      const allElements = Array.from(document.querySelectorAll('*'));
      
      const interactiveElements = allElements.filter(element => {
        // Check if element matches our base interactive selectors
        const isBaseInteractive = element.matches(baseSelectors);
        
        // Check if element has click event listeners
        const hasClickHandler = (element as HTMLElement).onclick || 
                              element.getAttribute('onclick') ||
                              element.hasAttribute('ng-click') || // Angular
                              element.hasAttribute('@click') ||   // Vue
                              element.hasAttribute('onClick');    // React
        
        return isBaseInteractive || hasClickHandler;
      });
      
      return interactiveElements.map(element => {
        const elementInfo: any = {
          type: element.tagName.toLowerCase(),
          text: element.textContent?.trim() || element.getAttribute('placeholder') || element.getAttribute('value') || '',
        };

        // Add href for links
        if (element instanceof HTMLAnchorElement && element.href) {
          elementInfo.href = element.href;
        }

        // Add id if present
        if (element.id) {
          elementInfo.id = element.id;
        }

        // Add class names if present
        if (element.className) {
          elementInfo.classes = element.className;
        }

        // Add input-specific attributes
        if (element instanceof HTMLInputElement) {
          elementInfo.inputType = element.type;
        }

        // Check for click handlers
        if ((element as HTMLElement).onclick || 
            element.getAttribute('onclick') ||
            element.hasAttribute('ng-click') ||
            element.hasAttribute('@click') ||
            element.hasAttribute('onClick')) {
          elementInfo.hasClickHandler = true;
        }

        return elementInfo;
      });
    });
  
    return new ToolMessage({
      tool_call_id: toolCallId,
      content: JSON.stringify(content, null, 2),
    });

  }, {
    name: 'Get Interactible Elements From Current Webpage',
    description: 'Returns a list of all interactible elements from the current webpage.',
    schema: z.undefined()
  });

  const loadWebpageTool = tool(async ({ url }: { url: string }, { toolCallId }: { toolCallId: string }): Promise<ToolMessage> => {
    console.log("tool call id: " + toolCallId)
    const newPage = await browser.newPage()
    await newPage.goto(url, { waitUntil: 'networkidle2' });
    
    return new ToolMessage({
      tool_call_id: toolCallId,
      "content": "Webpage loaded successfully. You can now use the 'Get Interactible Elements From Current Webpage' tool to get the interactible elements from the current webpage.",
    });

  }, {
    name: 'Load Webpage',
    description: 'Directs the current browser instance to load a webpage.',
    schema: z.object({
      url: z.string().describe('URL of website to load'),
    }),
  });

  const tools = [similaritySearchTool, loadWebpageTool, getInteractibleElementsTool];

  const toolNode = new ToolNode<typeof AgentState.State>(tools)
  const boundModel = llm.bindTools(tools)

    // Define the function that determines whether to continue or not
  const shouldContinue = ({ messages }: typeof MessagesAnnotation.State) => {
    console.log("should Continue called");
    const lastMessage = messages[messages.length - 1] as AIMessage;

    // If the LLM makes a tool call, then we route to the "tools" node
    if (lastMessage.tool_calls?.length) {
      return "action";
    }
    // Otherwise, we stop (reply to the user) using the special "__end__" node
    return "__end__";
  }

  const callModel = async (state: typeof MessagesAnnotation.State) => {
    console.log("Calling model");
    const response = await boundModel.invoke(state.messages);
    return { messages: [response] };
  }

  // agent = createReactAgent({ llm, tools, checkpointer: memory});
  const workflow = new StateGraph(AgentState)
    .addNode("agent", callModel)
    .addNode("action", toolNode)
    .addConditionalEdges(
        "agent",
        shouldContinue
    )
    .addEdge("action", "agent")
    .addEdge(START, "agent");


  agent = workflow.compile({
      checkpointer: memory,
  });
  console.log("Agent initialized");
};

const initBrowser = async () => {
  browser = await puppeteer.launch({ headless: false, executablePath: executablePath });
  console.log("chromium started");
}

// IPC to handle user queries
ipcMain.handle('runQuery', async (event, message:string) => {
  const humanMessage = new HumanMessage(message)
  const result = await agent.invoke({ messages: [humanMessage] },{ configurable: { thread_id: "1" } });
  return result.messages;
});

ipcMain.handle("webCrawlerTool", async (event, url) => {
  const response = await webCrawlerTool(url);
  const urlPages = Object.values(response)
  const urls = Object.keys(response)

  urlPages.map(async (urlPage: string, index: number) => {
    const sentences = await textSplitter.splitText(urlPage);
    const documents = sentences.map(sentence => ({
        pageContent: sentence,
        metadata: {url: urls[index]}
    }));
    await vectorStore.addDocuments(documents)
  })
});

const normalizeUrl = (url: string) => {
  // Remove protocol (http:// or https://)
  let normalized = url.replace(/^https?:\/\//, '');
  // Remove www prefix if present
  normalized = normalized.replace(/^www\./, '');
  return normalized;
};

const webCrawlerTool = async (startUrl: string) => {
  const browser = await puppeteer.launch({ headless: false, executablePath: executablePath });
  console.log("chromium started");
  console.log("new tab");
  const visited = new Set();
  const siteContent: Record<string, string> = {};
  const baseDomain= normalizeUrl(new URL(startUrl).origin);
  const maxLinks = 10

  const visitPage = async (url: string) => {
      if (visited.has(url)) return;
      visited.add(url);
      const newPage = await browser.newPage();
      try {
          await newPage.goto(url, { waitUntil: 'networkidle2' });
          const content = await newPage.evaluate(() => {
              document.querySelectorAll('script, style').forEach(el => el.remove());
              return document.body.innerText.trim();
          });

          console.log(`Visited ${url}`);

          siteContent[url] = content;
          
          const links = await newPage.evaluate(() => 
              Array.from(document.querySelectorAll('a[href]'))
                  .map(a => (a as HTMLAnchorElement).href.trim())
          );

          const filteredLinks = links.filter(link => normalizeUrl(link).startsWith(baseDomain) && !visited.has(link))
          await Promise.all(filteredLinks.map(link => {
            if (visited.size < maxLinks) {
                return visitPage(link);
            }
            return Promise.resolve();
          }));
      } catch (error) {
          console.error(`Failed to visit ${url}:`, error);
      }finally {
          // Close the individual tab after processing
          await newPage.close();
      }
  };

  await visitPage(startUrl);
  await browser.close();
  console.log("chromium closed");
  // console.log(siteContent)
  return siteContent;
}